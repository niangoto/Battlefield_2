<!DOCTYPE html>
<html lang="bg">
<head>
  <meta charset="UTF-8">
  <title>Lanchester Duel</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: sans-serif;
      background: #6b5d45; /* Зеленикаво-кафяв цвят за фон */
      color: #eee;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    h1 { 
      margin: 10px; 
      z-index: 1;
    }
    #controls { 
      margin-bottom: 10px; 
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      z-index: 1;
    }
    #setupPanel {
      background: #2b2b2b;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      max-width: 800px;
      z-index: 1;
    }
    .player-setup {
      display: flex;
      flex-direction: column;
      gap: 5px;
      margin-bottom: 10px;
    }
    .advanced-settings {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #444;
    }
    .settings-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    #gameCanvas {
      border: 2px solid #5a4c3a;
      background: #846f34; /* По-светъл зеленикаво-кафяв цвят за игралното поле */
      cursor: pointer;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
    .info-panel {
      margin-top: 10px;
      padding: 10px;
      background: #2b2b2b;
      border-radius: 5px;
      text-align: center;
      z-index: 1;
    }
    label {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    input[type="number"] {
      width: 60px;
    }
    .content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 1;
      position: relative;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <h1>Lanchester Duel</h1>
    
    <div id="setupPanel">
      <div style="display: flex; gap: 20px;">
        <div class="player-setup">
          <h3>Настройки за играч 1 (сини)</h3>
          <label>
            Брой отряди:
            <input type="number" id="player1Units" min="1" max="10" value="30">
          </label>
          <label>
            Начална стойност:
            <input type="number" id="player1Value" min="100" max="1000" step="100" value="100">
          </label>
        </div>
        
        <div class="player-setup">
          <h3>Настройки за играч 2 (червени)</h3>
          <label>
            Брой отряди:
            <input type="number" id="player2Units" min="1" max="10" value="30">
          </label>
          <label>
            Начална стойност:
            <input type="number" id="player2Value" min="100" max="1000" step="100" value="100">
          </label>
        </div>
      </div>
      
      <div class="advanced-settings">
        <div class="settings-group">
          <h3>Допълнителни настройки</h3>
          <label>
            Големина на отстъпление (%):
            <input type="number" id="retreatSize" min="10" max="200" value="100">
          </label>
          <label>
            Бързина на загубите във време:
            <input type="number" id="damageSpeed" min="100" max="2000" step="100" value="1000">
          </label>
        </div>
        
        <div class="settings-group">
          <h3 style="opacity: 0;">Допълнителни настройки</h3>
          <label>
            Разстояние между свои:
            <input type="number" id="friendlyDistance" min="0.1" max="2.0" step="0.1" value="1">
          </label>
          <label>
            Разстояние между вражески:
            <input type="number" id="enemyDistance" min="0.1" max="2.0" step="0.1" value="1">
          </label>
          <label>
            Максимален обхват за битка:
            <input type="number" id="battleRange" min="1.0" max="5.0" step="0.1" value="1.5">
          </label>
        </div>
      </div>
      
      <button id="startBtn">Започни игра</button>
    </div>
    
    <div id="controls">
      <button id="readyBtn">Готово</button>
      <button id="resetBtn">Нова игра</button>
      <button id="replayBtn">Повторение</button>
    </div>
    
    <div class="info-panel" id="gameInfo">
      Фаза: Разполагане | Играч 1 (сини) разполага отряди
    </div>
  </div>

  <canvas id="gameCanvas" width="1000" height="600"></canvas>

  <script>
    // Останалата част от JavaScript кода остава непроменена
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const gameInfo = document.getElementById("gameInfo");

    // Константи, които могат да се променят от потребителя
    let MAX_MOVE = 120;
    let MIN_FRACTION = 1/20;
    let UNIT_BASE = 100;
    let UNIT_SIZE = 30;
    let MIN_DISTANCE = 50;
    let BATTLE_SPEED = 0.01;
    let RETREAT_DAMAGE_FACTOR = 0.3;
    let ATTACK_ANGLE = Math.PI / 3; // 60 градуса за атакуващ сектор
    let MERGE_THRESHOLD = 0.5; // Праг за сливане (50% припокриване)
    let RETREAT_ANGLE_THRESHOLD = Math.PI / 4; // 45 градуса разлика за отстъпление
    let BASE_STEP = 12; // Базова стъпка за движение при отстъпление
    
    // Променливи за настройки
    let RETREAT_SIZE = 1.0; // Множител за големина на отстъпление
    let BATTLE_DAMAGE_FACTOR = 500; // Бързина на загубите
    let FRIENDLY_DISTANCE = 0.6; // Множител за разстояние между свои отряди
    let ENEMY_DISTANCE = 1.4; // Множител за разстояние между вражески отряди
    let BATTLE_RANGE = 2.5; // Множител за обхват на битка

    let gamePhase = "setup";
    let currentPlayer = 1;
    let units = [];
    let selectedUnits = [];
    let isSelecting = false;
    let isDrawingPath = false;
    let currentPath = [];
    let selectionRect = { startX: 0, startY: 0, endX: 0, endY: 0 };
    let player1Units = 3;
    let player1Value = 100;
    let player2Units = 3;
    let player2Value = 100;
    let unitsToPlace = 0;
    let battleAnimation = null;
    // BATTLE_MAX_TIME се изчислява динамично според максималното разстояние и скоростта
    const BATTLE_MAX_TIME = Math.ceil((MAX_MOVE / (MAX_MOVE * BATTLE_SPEED)) * 1000); // време в ms
    let battleElapsedTime = 0;
    let battleEndTimeout = null;
    let gameHistory = [];
    let isReplaying = false;

    // Инициализация на UI елементи
    document.getElementById("startBtn").addEventListener("click", startGame);
    document.getElementById("readyBtn").addEventListener("click", handleReady);
    document.getElementById("resetBtn").addEventListener("click", resetGame);
    document.getElementById("replayBtn").addEventListener("click", playReplay);

    // Функция за преоразмеряване на canvas според размера на екрана
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw();
    }

    // Слушател за преоразмеряване на прозореца
    window.addEventListener('resize', resizeCanvas, false);
    resizeCanvas(); // Инициализиране на размера при зареждане

    function startGame() {
      player1Units = parseInt(document.getElementById("player1Units").value);
      player1Value = parseInt(document.getElementById("player1Value").value);
      player2Units = parseInt(document.getElementById("player2Units").value);
      player2Value = parseInt(document.getElementById("player2Value").value);
      
      // Зареждане на допълнителните настройки
      RETREAT_SIZE = parseInt(document.getElementById("retreatSize").value) / 100;
      BATTLE_DAMAGE_FACTOR = parseInt(document.getElementById("damageSpeed").value);
      FRIENDLY_DISTANCE = parseFloat(document.getElementById("friendlyDistance").value);
      ENEMY_DISTANCE = parseFloat(document.getElementById("enemyDistance").value);
      BATTLE_RANGE = parseFloat(document.getElementById("battleRange").value);
      
      gamePhase = "placement";
      currentPlayer = 1;
      unitsToPlace = currentPlayer === 1 ? player1Units : player2Units;
      
      document.getElementById("setupPanel").style.display = "none";
      updateGameInfo();
      draw();
    }

    function resetGame() {
      gamePhase = "setup";
      units = [];
      currentPlayer = 1;
      selectedUnits = [];
      if (battleAnimation) {
        clearInterval(battleAnimation);
        battleAnimation = null;
      }
      if (battleEndTimeout) {
        clearTimeout(battleEndTimeout);
        battleEndTimeout = null;
      }
      gameHistory = [];
      document.getElementById("setupPanel").style.display = "flex";
      updateGameInfo();
      draw();
    }

    function handleReady() {
      if (gamePhase === "placement") {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        unitsToPlace = currentPlayer === 1 ? player1Units : player2Units;
        
        if (currentPlayer === 1) {
          // Ако се връщаме към играч 1, значи играч 2 е готов
          gamePhase = "movementSetup";
          // currentPlayer е вече 1
        }
        
      } else if (gamePhase === "movementSetup") {
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        
        if (currentPlayer === 1) {
          // Ако се връщаме към играч 1, значи играч 2 е готов
          gameHistory.push(JSON.parse(JSON.stringify(units))); // Запазване на състоянието преди битка
          gamePhase = "battle";
          animateBattle();
        }
      } else if (gamePhase === "battle") {
        for (let u of units) { 
          u.target = null; 
          u.orderGiven = false; 
          u.damage = 0;
          u.retreating = false;
          delete u.targetValue;
        }
        if (battleAnimation) {
          clearInterval(battleAnimation);
          battleAnimation = null;
        }
        if (battleEndTimeout) {
          clearTimeout(battleEndTimeout);
          battleEndTimeout = null;
        }
        gamePhase = "movementSetup";
        currentPlayer = 1;
      } else if (gamePhase === "battleEnded") {
        // Позволяваме рестарт на движенията след край на битката
        for (let u of units) { 
          u.target = null; 
          u.orderGiven = false; 
          u.damage = 0;
          u.retreating = false;
          delete u.targetValue;
        }
        gamePhase = "movementSetup";
        currentPlayer = 1;
        updateGameInfo();
        draw();
      }
      updateGameInfo();
      draw();
    }

    function playReplay() {
      if (isReplaying || gameHistory.length === 0) {
        return;
      }
      isReplaying = true;
      document.getElementById("readyBtn").disabled = true;
      document.getElementById("resetBtn").disabled = true;
      document.getElementById("replayBtn").disabled = true;
      gameInfo.textContent = "Повторение...";

      let currentRound = 0;

      function playNextRound() {
        if (currentRound >= gameHistory.length) {
          isReplaying = false;
          document.getElementById("readyBtn").disabled = false;
          document.getElementById("resetBtn").disabled = false;
          document.getElementById("replayBtn").disabled = false;
          // Връщане към последното реално състояние на играта
          units = JSON.parse(JSON.stringify(gameHistory[gameHistory.length - 1]));
          gamePhase = "battleEnded"; // Отиваме в състояние след битка
          updateGameInfo();
          draw();
          // Извикваме handleReady, за да преминем към следващия рунд на движение
          setTimeout(() => handleReady(), 100); 
          return;
        }

        units = JSON.parse(JSON.stringify(gameHistory[currentRound]));
        
        // Изчисляваме времето за битката за този рунд
        let maxDistance = 0;
        for (let u of units) {
          if (u.target && typeof u.target.distance === 'number') {
            if (u.target.distance > maxDistance) maxDistance = u.target.distance;
          }
        }
        if (maxDistance === 0) maxDistance = MAX_MOVE;
        const battleTime = (maxDistance / (MAX_MOVE * BATTLE_SPEED)) * 40;

        animateBattle(); // Пускаме анимацията

        // Изчакваме края на текущата анимация и пускаме следващата
        setTimeout(() => {
          currentRound++;
          playNextRound();
        }, battleTime + 200); // +200ms пауза между рундовете
      }

      playNextRound();
    }

    function updateGameInfo() {
      let infoText = "";
      
      switch(gamePhase) {
        case "setup":
          infoText = "Настройте играта и натиснете 'Започни игра'";
          break;
        case "placement":
          infoText = `Фаза: Разполагане | Играч ${currentPlayer} (${currentPlayer === 1 ? "сини" : "червени"}) разполага отряди | Оставащи: ${unitsToPlace}`;
          break;
        case "movementSetup":
          infoText = `Фаза: Задаване на движения | Играч ${currentPlayer} (${currentPlayer === 1 ? "сини" : "червени"}) задава посоки`;
          // Показваме колко отряда имат зададени команди
          const playerUnits = units.filter(u => u.player === currentPlayer);
          const unitsWithOrders = playerUnits.filter(u => u.orderGiven).length;
          infoText += ` | Зададени команди: ${unitsWithOrders}/${playerUnits.length}`;
          break;
        case "battle":
          infoText = "Фаза: Битка | Изпълнява се битката";
          // Показваме общата стойност на всеки играч
          const p1Value = units.filter(u => u.player === 1).reduce((sum, u) => sum + u.value, 0);
          const p2Value = units.filter(u => u.player === 2).reduce((sum, u) => sum + u.value, 0);
          infoText += ` | Сини: ${Math.round(p1Value)} | Червени: ${Math.round(p2Value)}`;
          break;
        case "battleEnded":
          const p1End = units.filter(u => u.player === 1).reduce((sum, u) => sum + u.value, 0);
          const p2End = units.filter(u => u.player === 2).reduce((sum, u) => sum + u.value, 0);
          infoText = `Край на рунда | Сини: ${Math.round(p1End)} | Червени: ${Math.round(p2End)} | Натиснете 'Готово' за следващ рунд`;
          break;
      }
      
      gameInfo.textContent = infoText;
    }

    canvas.addEventListener("mousedown", (e) => {
      const {x, y} = getMouse(e);
      if (gamePhase === "movementSetup") {
        const clickedUnit = getUnitAt(x, y);
        if (selectedUnits.length > 0 && !clickedUnit) {
          isDrawingPath = true;
          
          // Изчисляване на центъра на групата
          let sumX = 0, sumY = 0;
          for (let unit of selectedUnits) {
            sumX += unit.x;
            sumY += unit.y;
          }
          const originX = sumX / selectedUnits.length;
          const originY = sumY / selectedUnits.length;

          currentPath = [{x: originX, y: originY}];
        } else {
          isSelecting = true;
          selectionRect.startX = x;
          selectionRect.startY = y;
          selectionRect.endX = x;
          selectionRect.endY = y;
        }
      }
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDrawingPath) {
        const {x, y} = getMouse(e);
        let totalDist = 0;
        for (let i = 1; i < currentPath.length; i++) {
          totalDist += distance(currentPath[i], currentPath[i-1]);
        }
        const lastPoint = currentPath[currentPath.length - 1];
        const newSegmentDist = distance(lastPoint, {x, y});

        if (totalDist + newSegmentDist <= MAX_MOVE) {
          currentPath.push({x, y});
          draw();
        }
      } else if (isSelecting) {
        const {x, y} = getMouse(e);
        selectionRect.endX = x;
        selectionRect.endY = y;
        draw();
      }
    });

    canvas.addEventListener("mouseup", (e) => {
      const {x, y} = getMouse(e);
      
      if (gamePhase === "placement") {
        // Проверка дали позицията е в съответната половина на полето
        const inPlayerHalf = (currentPlayer === 1 && x < canvas.width/2) || 
                            (currentPlayer === 2 && x > canvas.width/2);
        
        if (!inPlayerHalf) {
          alert("Можете да разполагате отряди само във вашата половина на полето!");
          return;
        }
        
        // Проверка за минимално разстояние между отряди
        let tooClose = false;
        for (const unit of units) {
          let minDist;
          if (unit.player === currentPlayer) {
            minDist = FRIENDLY_DISTANCE * getSize(unit);
          } else {
            minDist = ENEMY_DISTANCE * getSize(unit);
          }
          if (distance({x, y}, unit) < minDist) {
            tooClose = true;
            break;
          }
        }
        if (tooClose) {
          alert(`Отрядите трябва да са на поне ${FRIENDLY_DISTANCE} (свои) или ${ENEMY_DISTANCE} (вражески) от ширината си разстояние един от друг!`);
          return;
        }
        
        const unitValue = currentPlayer === 1 ? player1Value : player2Value;
        addUnit(x, y, currentPlayer, unitValue);
        unitsToPlace--;
        
        if (unitsToPlace <= 0) {
          // Автоматично преминаване към следващия играч
          handleReady();
        }
      } else if (gamePhase === "movementSetup") {
        if (isDrawingPath) {
          isDrawingPath = false;
          
          const origin = currentPath[0];
          let totalDistance = 0;
          for (let i = 1; i < currentPath.length; i++) {
            totalDistance += distance(currentPath[i-1], currentPath[i]);
          }

          for (let unit of selectedUnits) {
            const offsetX = unit.x - origin.x;
            const offsetY = unit.y - origin.y;

            const unitPath = currentPath.map(p => ({ x: p.x + offsetX, y: p.y + offsetY }));
            
            // Задаваме целта като сложен обект с път
            unit.target = {
              path: unitPath,
              totalDistance: totalDistance,
              progress: 0,
              // За съвместимост, angle и крайна точка
              x: unitPath[unitPath.length - 1].x,
              y: unitPath[unitPath.length - 1].y,
              angle: Math.atan2(unitPath[unitPath.length - 1].y - unitPath[unitPath.length - 2].y, unitPath[unitPath.length - 1].x - unitPath[unitPath.length - 2].x) || unit.angle,
              distance: totalDistance
            };
            unit.orderGiven = true;
          }
          selectedUnits = [];
          currentPath = [];

        } else if (isSelecting) {
          isSelecting = false;
          const isClick = Math.abs(selectionRect.startX - x) < 5 && Math.abs(selectionRect.startY - y) < 5;

          if (isClick) {
            // Логика за единичен клик
            const clickedUnit = getUnitAt(x, y);
            if (clickedUnit && clickedUnit.player === currentPlayer) {
              if (e.shiftKey) {
                // Добавяне/премахване от селекцията с Shift
                const index = selectedUnits.indexOf(clickedUnit);
                if (index > -1) {
                  selectedUnits.splice(index, 1);
                } else {
                  selectedUnits.push(clickedUnit);
              }
              } else {
                // Нормална селекция
                selectedUnits = [clickedUnit];
              }
            } else if (selectedUnits.length > 0) {
              // Задаване на цел за всички избрани
              let originX, originY;
              if (selectedUnits.length > 1) {
                // Изчисляване на центъра на групата
                let sumX = 0, sumY = 0;
                for (let unit of selectedUnits) {
                  sumX += unit.x;
                  sumY += unit.y;
                }
                originX = sumX / selectedUnits.length;
                originY = sumY / selectedUnits.length;
              } else {
                // Използване на позицията на единствения отряд
                originX = selectedUnits[0].x;
                originY = selectedUnits[0].y;
              }

              for (let selectedUnit of selectedUnits) {
                const dx = x - originX;
                const dy = y - originY;
                const dist = Math.sqrt(dx*dx+dy*dy);
                const scale = dist > MAX_MOVE ? MAX_MOVE/dist : 1;
                selectedUnit.target = {
                  x: selectedUnit.x + dx*scale,
                  y: selectedUnit.y + dy*scale,
                  dx: dx*scale,
                  dy: dy*scale,
                  angle: Math.atan2(dy, dx),
                  distance: Math.min(dist, MAX_MOVE),
                  progress: 0
                };
                selectedUnit.orderGiven = true;
              }
              selectedUnits = [];
            } else {
              selectedUnits = []; // Изчистване на селекцията при клик на празно място
            }
          } else {
            // Логика за правоъгълна селекция
            const rect = {
              x: Math.min(selectionRect.startX, x),
              y: Math.min(selectionRect.startY, y),
              width: Math.abs(selectionRect.startX - x),
              height: Math.abs(selectionRect.startY - y)
            };
            const newlySelected = units.filter(u => 
              u.player === currentPlayer &&
              u.x > rect.x && u.x < rect.x + rect.width &&
              u.y > rect.y && u.y < rect.y + rect.height
            );
            if (e.shiftKey) {
              // Добавяне към съществуващата селекция
              for (const unit of newlySelected) {
                if (!selectedUnits.includes(unit)) {
                  selectedUnits.push(unit);
                }
              }
            } else {
              selectedUnits = newlySelected;
            }
          }
        }
      }
      
      updateGameInfo();
      draw();
    });

    canvas.addEventListener("dblclick", (e) => {
      // Премахната функционалност
    });

    function getMouse(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function addUnit(x, y, player, value) {
      units.push({
        x, y, player, value, 
        initialValue: value,
        target: null, 
        orderGiven: false, 
        alive: true,
        damage: 0,
        retreating: false,
        angle: player === 1 ? Math.PI/2 : -Math.PI/2 // Начална ориентация към центъра
      });
    }

    function getUnitAt(x, y) {
      return units.find(u =>
        x > u.x - getSize(u)/2 && x < u.x + getSize(u)/2 &&
        y > u.y - getSize(u)/2 && y < u.y + getSize(u)/2
      );
    }

    function getSize(u) { 
      return UNIT_SIZE; 
    }

    function distance(a, b) { 
        return Math.hypot(a.x - b.x, a.y - b.y); 
      }

    function animateBattle() {
      if (battleAnimation) {
        clearInterval(battleAnimation);
      }
      if (battleEndTimeout) {
        clearTimeout(battleEndTimeout);
        battleEndTimeout = null;
      }
      battleElapsedTime = 0;
      // Изчисляваме максималната дължина на стрелка
      let maxDistance = 0;
      for (let u of units) {
        if (u.target && typeof u.target.distance === 'number') {
          if (u.target.distance > maxDistance) maxDistance = u.target.distance;
        }
      }
      // Ако няма зададени стрелки, използваме MAX_MOVE
      if (maxDistance === 0) maxDistance = MAX_MOVE;
      
      // Времето за битка се изчислява на базата на максималната дистанция и скоростта на движение
      const battleTime = (maxDistance / (MAX_MOVE * BATTLE_SPEED)) * 40; // 40ms е интервалът на анимацията

      const battleStartTime = Date.now();
      battleEndTimeout = setTimeout(() => {
        if (battleAnimation) {
          clearInterval(battleAnimation);
          battleAnimation = null;
        }
        gamePhase = "battleEnded";
        updateGameInfo();
        draw(true);
      }, battleTime);
      battleAnimation = setInterval(() => {
        battleElapsedTime = Date.now() - battleStartTime;
        if (battleElapsedTime >= battleTime) {
          clearInterval(battleAnimation);
          battleAnimation = null;
          return;
        }
        let allFinished = true;

        // Проверка дали отрядите трябва да спрат да отстъпват
        for (let u of units) {
          if (u.retreating && u.retreatTarget) {
            // Ако вече няма враг в обсега, спира да отстъпва
            const attackers = units.filter(v => v.player !== u.player && distance(u, v) < getSize(u) * BATTLE_RANGE);
            if (attackers.length === 0) {
              u.retreating = false;
              if (u.originalTarget) {
                u.target = u.originalTarget;
                u.retreatTarget = null;
                u.orderGiven = true;
              }
            }
          }
        }

        // 1. Движение на отрядите
        for (let u of units) {
          if (u.target && u.target.progress < 1) {
            
            let hasObstacle = false;
            let nextX, nextY, moveAngle;
            const moveIncrement = 0.01; // Corresponds to BATTLE_SPEED

            if (u.retreating && u.retreatTarget) {
                // Unit is retreating
                moveAngle = u.retreatTarget.angle;
                const moveDx = u.retreatTarget.dx;
                const moveDy = u.retreatTarget.dy;
                nextX = u.x + moveDx * moveIncrement;
                nextY = u.y + moveDy * moveIncrement;
            } else if (u.target.path && u.target.path.length > 1) {
                // Unit is following a curved path
                const newProgress = Math.min(u.target.progress + moveIncrement, 1);
                const traveledSoFar = u.target.progress * u.target.totalDistance;
                const newTotalTraveled = newProgress * u.target.totalDistance;

                let segmentStart = u.target.path[0];
                let segmentEnd = u.target.path[1];
                let distanceAlongPath = 0;

                for (let i = 1; i < u.target.path.length; i++) {
                    const currentSegmentLength = distance(u.target.path[i-1], u.target.path[i]);
                    if (traveledSoFar < distanceAlongPath + currentSegmentLength) {
                        segmentStart = u.target.path[i-1];
                        segmentEnd = u.target.path[i];
                        break;
                    }
                    distanceAlongPath += currentSegmentLength;
                }
                
                const segmentVector = { x: segmentEnd.x - segmentStart.x, y: segmentEnd.y - segmentStart.y };
                const segmentLength = distance(segmentStart, segmentEnd);
                const segmentAngle = Math.atan2(segmentVector.y, segmentVector.x);

                const distanceToMove = newTotalTraveled - traveledSoFar;
                const dx = Math.cos(segmentAngle) * distanceToMove;
                const dy = Math.sin(segmentAngle) * distanceToMove;

                nextX = u.x + dx;
                nextY = u.y + dy;
                moveAngle = segmentAngle; // Текущ ъгъл на сегмента
            } else {
                // Unit has a straight target
                moveAngle = u.target.angle; // Ъгълът остава същият за праволинейно движение
                const moveDx = u.target.dx;
                const moveDy = u.target.dy;
                nextX = u.x + moveDx * moveIncrement;
                nextY = u.y + moveDy * moveIncrement;
            }

            // Obstacle detection - променена логика за откриване на свои отряди
            for (let other of units) {
              if (other !== u) {
                let minDist = (u.player === other.player) ? FRIENDLY_DISTANCE * getSize(u) : ENEMY_DISTANCE * getSize(u);
                if (distance({x: nextX, y: nextY}, other) < minDist) {
                  hasObstacle = true;
                  
                  // Ако отстъпваме и имаме препятствие от същия играч
                  if ((u.retreating || (!u.target || u.target.progress >= 1)) && u.player === other.player) {
                    // ИЗПОЛЗВАМЕ СЪЩАТА ФУНКЦИЯ applyRetreatPush
                    applyRetreatPush(u, other);
                  }
                  
                  break;
                }
              }
            }

            // Update position if no obstacle
            if (!hasObstacle) {
              u.target.progress += moveIncrement;
              u.x = nextX;
              u.y = nextY;
              u.angle = moveAngle; // Актуализираме ъгъла с текущата посока на движение
            }

            if (u.retreating && u.target.progress >= 1 && u.retreatTarget) {
              u.retreating = false;
              u.target = u.originalTarget;
              u.retreatTarget = null;
              u.orderGiven = true;
            }
            allFinished = allFinished && (u.target.progress >= 1);
          }
        }

        // 2. Проверка за сблъсъци и сливане
        mergeOverlaps();

        // 3. Проверка за битка и отстъпление
        executeBattleStep();

        // 4. Проверка за край на битката
        draw(true);
      }, 40);
    }
    function executeBattleStep() {
      // Нулиране на щетите
      for (let u of units) { 
        u.damage = 0; 
        u.attackingValue = 0;
      }
      
      // Определяне на цели и изчисляване на атакуващата сила
      for (let u of units) {
        const attackRange = getSize(u) * BATTLE_RANGE;
        const enemies = units.filter(v => v.player !== u.player && distance(u, v) < attackRange);
        if (enemies.length > 0) {
          let inSector = [];
          let outOfSector = [];
          for (let e of enemies) {
            let angToEnemy = Math.atan2(e.y - u.y, e.x - u.x);
            let angleDiff = u.target ? Math.abs(normalizeAngle(angToEnemy - u.target.angle)) : Math.PI;
            if (angleDiff <= ATTACK_ANGLE / 2) {
              inSector.push(e);
            } else {
              outOfSector.push(e);
            }
          }
          const totalInSectorValue = inSector.reduce((sum, e) => sum + e.value, 0);
          const totalOutOfSectorValue = outOfSector.reduce((sum, e) => sum + e.value, 0);
          if (inSector.length > 0) {
            const attackPower = u.value * 0.9;
            for (let e of inSector) {
              const allocatedPower = attackPower * (e.value / totalInSectorValue);
              e.attackingValue += allocatedPower;
            }
          }
          if (outOfSector.length > 0) {
            const attackPower = u.value * 0.1;
            for (let e of outOfSector) {
              const allocatedPower = attackPower * (e.value / totalOutOfSectorValue);
              e.attackingValue += allocatedPower;
            }
          }
        }
      }
      
      // Прилагане на щетите и определяне на отстъпления
      for (let u of units) {
        if (u.attackingValue > 0) {
          u.damage = u.attackingValue / BATTLE_DAMAGE_FACTOR;
          u.value = Math.max(u.value - u.damage, 0);
          if (u.attackingValue > u.value && !u.retreating) {
            u.retreating = true;
            // Запазваме оригиналната цел, ако не е запазена
            if (!u.originalTarget && u.target) {
              u.originalTarget = Object.assign({}, u.target);
            }
            let retreatVector = {x: 0, y: 0};
            const attackers = units.filter(v => v.player !== u.player && distance(u, v) < getSize(u) * BATTLE_RANGE);
            for (let a of attackers) {
              let dx = u.x - a.x;
              let dy = u.y - a.y;
              let distanceToAttacker = Math.hypot(dx, dy) || 1;
              retreatVector.x += (dx / distanceToAttacker) * a.value;
              retreatVector.y += (dy / distanceToAttacker) * a.value;
            }
            let retreatAngle = Math.atan2(retreatVector.y, retreatVector.x);
            
            const retreatRatio = Math.min(u.attackingValue / (u.value || 1), 4);
            const retreatDistance = BASE_STEP * retreatRatio * RETREAT_SIZE;

            let angleDiff = u.target ? Math.abs(normalizeAngle(retreatAngle - u.target.angle)) : Math.PI;

            if (angleDiff > RETREAT_ANGLE_THRESHOLD) {
              // Разликата е голяма, изпълнява се отстъпление
              u.retreatTarget = {
                x: u.x + Math.cos(retreatAngle) * retreatDistance,
                y: u.y + Math.sin(retreatAngle) * retreatDistance,
                dx: Math.cos(retreatAngle) * retreatDistance,
                dy: Math.sin(retreatAngle) * retreatDistance,
                angle: retreatAngle,
                distance: retreatDistance,
                progress: 0
              };
              u.target = u.retreatTarget;
            } else {
              // Разликата е малка, следва се оригиналната посока, но с малка стъпка
              const originalAngle = u.target.angle;
              u.retreatTarget = {
                x: u.x + Math.cos(originalAngle) * BASE_STEP,
                y: u.y + Math.sin(originalAngle) * BASE_STEP,
                dx: Math.cos(originalAngle) * BASE_STEP,
                dy: Math.sin(originalAngle) * BASE_STEP,
                angle: originalAngle,
                distance: BASE_STEP,
                progress: 0
              };
              u.target = u.retreatTarget;
            }
            u.orderGiven = true;
          }
        }
      }
      
      // Щети към атакуващите при отстъпление
      for (let u of units) {
        if (u.retreating) {
          const attackers = units.filter(v => v.player !== u.player && distance(u, v) < getSize(u) * BATTLE_RANGE);
          const damageToAttackers = u.value / BATTLE_DAMAGE_FACTOR;
          if (attackers.length > 0) {
            const damagePerAttacker = damageToAttackers / attackers.length;
            for (let a of attackers) {
              a.value = Math.max(a.value - damagePerAttacker, 0);
            }
          }
        }
      }
      
      // Избутване на съседни отряди от отстъпващите
      for (let u of units) {
        if (u.retreating) {
          for (let other of units) {
            if (other !== u && other.player === u.player) {
              let minDist = FRIENDLY_DISTANCE * getSize(u);
              if (distance(u, other) < minDist) {
                applyRetreatPush(u, other);
              }
            }
          }
        }
      }
      
      removeWeak();
    }

    // Избутване на съседен отряд
    function applyRetreatPush(retreatingUnit, pushedUnit) {
      // Определяме посоката на избутване
      let pushAngle;
      if (retreatingUnit.retreating && retreatingUnit.target) {
        // Ако отстъпва, използваме посоката на отстъпление
        pushAngle = retreatingUnit.target.angle;
      } else if (retreatingUnit.target) {
        // Ако има нормална цел, използваме посоката към целта
        pushAngle = retreatingUnit.target.angle;
      } else {
        // Ако няма цел, използваме текущата посока
        pushAngle = retreatingUnit.angle;
      }
      
      // Изчисляваме силата на избутване: 70% * (стойност А / стойност В)
      const retreatRatio = 0.7 * (retreatingUnit.value / pushedUnit.value);
      const finalRatio = Math.min(retreatRatio, 1);
      
      const pushDistance = BASE_STEP * finalRatio * RETREAT_SIZE;

      // Проверяваме дали избутваният отряд вече има движение
      if (pushedUnit.target && pushedUnit.target.progress < 1) {
        // Проверяваме ъгъла между текущото движение на В и посоката на избутване
        const currentAngle = pushedUnit.target.angle;
        const angleDiff = Math.abs(normalizeAngle(pushAngle - currentAngle));
        const angleThreshold = Math.PI / 2; // 90 градуса
        
        // ИЗБУТВАМЕ САМО ПРИ ЪГЪЛ > 90 ГРАДУСА
        if (angleDiff > angleThreshold) {
          // Създаваме ново движение в посоката на избутване
          pushedUnit.target = {
            x: pushedUnit.x + Math.cos(pushAngle) * pushDistance,
            y: pushedUnit.y + Math.sin(pushAngle) * pushDistance,
            dx: Math.cos(pushAngle) * pushDistance,
            dy: Math.sin(pushAngle) * pushDistance,
            angle: pushAngle,
            distance: pushDistance,
            progress: 0
          };
          
          // Маркираме като отстъпващ само ако избутващият отстъпва
          if (retreatingUnit.retreating) {
            pushedUnit.retreating = true;
            if (!pushedUnit.originalTarget) {
              pushedUnit.originalTarget = Object.assign({}, pushedUnit.target);
            }
          }
          pushedUnit.orderGiven = true;
        }
        // Ако ъгълът е ≤ 90 градуса, не правим нищо - изпълнява се зададеното движение
      } else {
        // Ако избутваният отряд няма движение, винаги го избутваме
        pushedUnit.target = {
          x: pushedUnit.x + Math.cos(pushAngle) * pushDistance,
          y: pushedUnit.y + Math.sin(pushAngle) * pushDistance,
          dx: Math.cos(pushAngle) * pushDistance,
          dy: Math.sin(pushAngle) * pushDistance,
          angle: pushAngle,
          distance: pushDistance,
          progress: 0
        };
        
        // Маркираме като отстъпващ само ако избутващият отстъпва
        if (retreatingUnit.retreating) {
          pushedUnit.retreating = true;
          if (!pushedUnit.originalTarget && pushedUnit.target) {
            pushedUnit.originalTarget = Object.assign({}, pushedUnit.target);
          }
        }
        pushedUnit.orderGiven = true;
      }
    }
    function normalizeAngle(a) {
      while (a > Math.PI) a -= 2 * Math.PI;
      while (a < -Math.PI) a += 2 * Math.PI;
      return a;
    }

    function removeWeak() {
      units = units.filter(u => u.value >= u.initialValue * 0.33);
    }

    function mergeOverlaps() {
      for (let i = 0; i < units.length; i++) {
        for (let j = i + 1; j < units.length; j++) {
          let a = units[i], b = units[j];
          if (a.player === b.player) {
            const dist = distance(a, b);
            const minDist = FRIENDLY_DISTANCE * getSize(a);
            // Проверка за припокриване над 50%
            if (dist < minDist * MERGE_THRESHOLD) {
              a.value += b.value;
              a.initialValue += b.initialValue;
              if (b.target && !a.target) {
                a.target = b.target;
                a.orderGiven = true;
              }
              units.splice(j, 1);
              j--;
            }
          }
        }
      }
    }

    function draw(hideArrows = false) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Рисуване на разделителна линия
      ctx.strokeStyle = "#444";
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Рисуване на отряди
      for (let u of units) {
        // Пропускаме скритите отряди по време на разполагане
        if (gamePhase === "placement" && u.player !== currentPlayer) continue;
        
        ctx.fillStyle = u.player === 1 ? "blue" : "red";
        if (u.retreating) {
          ctx.fillStyle = u.player === 1 ? "#4444ff" : "#ff4444"; // По-светъл цвят при отстъпление
        }
        
        const size = getSize(u);
        // Рисуване на квадрат, обърнат в посока на движение
        ctx.save();
        ctx.translate(u.x, u.y);
        // Използваме текущата посока на отряда (u.angle) вместо ъгъла на целта
        ctx.rotate(u.angle + Math.PI / 2); // +90 градуса за вертикална ориентация
        // Квадрат със страна size
        ctx.fillRect(-size / 2, -size / 2, size, size);
        ctx.restore();
        
        // Рисуване на стойността
        ctx.fillStyle = "white";
        const fontSize = Math.max(10, Math.min(20, 10 + u.value / 20));
        ctx.font = `${fontSize}px Arial`;
        ctx.textAlign = "center";
        ctx.fillText(Math.round(u.value), u.x, u.y + 5);
        
        // Рисуване на стрелки за движение
        if (u.target && !hideArrows && (gamePhase === "movementSetup" || gamePhase === "battle") && u.player === currentPlayer) {
          ctx.strokeStyle = u.retreating ? "orange" : "yellow";
          ctx.lineWidth = 2;
          ctx.beginPath();
          if (u.target.path) {
            // Рисуване на крива пътека
            const origin = u.target.path[0];
            const offsetX = u.x - origin.x;
            const offsetY = u.y - origin.y;
            ctx.moveTo(u.x, u.y);
            for (let i = 1; i < u.target.path.length; i++) {
              ctx.lineTo(u.target.path[i].x + offsetX, u.target.path[i].y + offsetY);
            }
          } else {
            // Рисуване на права линия
            ctx.moveTo(u.x, u.y);
            ctx.lineTo(u.target.x, u.target.y);
          }
          ctx.stroke();
          
          // Рисуване на върха на стрелката
          const arrowSize = 10;
          ctx.save();
          ctx.translate(u.target.x, u.target.y);
          ctx.rotate(u.target.angle);
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(-arrowSize, -arrowSize / 2);
          ctx.lineTo(-arrowSize, arrowSize / 2);
          ctx.closePath();
          ctx.fillStyle = u.retreating ? "orange" : "yellow";
          ctx.fill();
          ctx.restore();
        }
      }
      
      // Рисуване на избрания отряд
      if (selectedUnits.length > 0) {
        ctx.strokeStyle = "cyan";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        for (let selectedUnit of selectedUnits) {
          ctx.beginPath();
          ctx.arc(selectedUnit.x, selectedUnit.y, getSize(selectedUnit) / 2 + 5, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.setLineDash([]);
      }

      // Рисуване на правоъгълника за селекция
      if (isSelecting) {
        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.strokeRect(selectionRect.startX, selectionRect.startY, selectionRect.endX - selectionRect.startX, selectionRect.endY - selectionRect.startY);
        ctx.setLineDash([]);
      }

      // Рисуване на текущо чертания път
      if (isDrawingPath && currentPath.length > 1) {
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(currentPath[0].x, currentPath[0].y);
        for (let i = 1; i < currentPath.length; i++) {
          ctx.lineTo(currentPath[i].x, currentPath[i].y);
        }
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Инициализация
    draw();
  </script> 
</body>
</html>
